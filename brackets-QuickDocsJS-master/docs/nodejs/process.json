{"abort":{"y":"process.abort()","s":"<p>This causes node to emit an abort. This will cause node to exit and\ngenerate a core file.\n\n<\/p>\n","p":[]},"chdir":{"y":"process.chdir(directory)","s":"<p>Changes the current working directory of the process or throws an exception if that fails.\n\n<\/p>\n<pre><code>console.log(&#39;Starting directory: &#39; + process.cwd());\ntry {\n  process.chdir(&#39;\/tmp&#39;);\n  console.log(&#39;New directory: &#39; + process.cwd());\n}\ncatch (err) {\n  console.log(&#39;chdir: &#39; + err);\n}<\/code><\/pre>\n","p":[{"o":false,"t":"directory","d":"","type":""}]},"cwd":{"y":"process.cwd()","s":"<p>Returns the current working directory of the process.\n\n<\/p>\n<pre><code>console.log(&#39;Current directory: &#39; + process.cwd());<\/code><\/pre>\n","p":[]},"exit":{"y":"process.exit([code])","s":"<p>Ends the process with the specified <code>code<\/code>.  If omitted, exit uses the\n&#39;success&#39; code <code>0<\/code>.\n\n<\/p>\n<p>To exit with a &#39;failure&#39; code:\n\n<\/p>\n<pre><code>process.exit(1);<\/code><\/pre>\n<p>The shell that executed node should see the exit code as 1.\n\n\n<\/p>\n","p":[{"o":true,"t":"code","d":"","type":""}]},"getgid":{"y":"process.getgid()","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Gets the group identity of the process. (See getgid(2).)\nThis is the numerical group id, not the group name.\n\n<\/p>\n<pre><code>if (process.getgid) {\n  console.log(&#39;Current gid: &#39; + process.getgid());\n}<\/code><\/pre>\n","p":[]},"setgid":{"y":"process.setgid(id)","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Sets the group identity of the process. (See setgid(2).)  This accepts either\na numerical ID or a groupname string. If a groupname is specified, this method\nblocks while resolving it to a numerical ID.\n\n<\/p>\n<pre><code>if (process.getgid &amp;&amp; process.setgid) {\n  console.log(&#39;Current gid: &#39; + process.getgid());\n  try {\n    process.setgid(501);\n    console.log(&#39;New gid: &#39; + process.getgid());\n  }\n  catch (err) {\n    console.log(&#39;Failed to set gid: &#39; + err);\n  }\n}<\/code><\/pre>\n","p":[{"o":false,"t":"id","d":"","type":""}]},"getuid":{"y":"process.getuid()","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Gets the user identity of the process. (See getuid(2).)\nThis is the numerical userid, not the username.\n\n<\/p>\n<pre><code>if (process.getuid) {\n  console.log(&#39;Current uid: &#39; + process.getuid());\n}<\/code><\/pre>\n","p":[]},"setuid":{"y":"process.setuid(id)","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Sets the user identity of the process. (See setuid(2).)  This accepts either\na numerical ID or a username string.  If a username is specified, this method\nblocks while resolving it to a numerical ID.\n\n<\/p>\n<pre><code>if (process.getuid &amp;&amp; process.setuid) {\n  console.log(&#39;Current uid: &#39; + process.getuid());\n  try {\n    process.setuid(501);\n    console.log(&#39;New uid: &#39; + process.getuid());\n  }\n  catch (err) {\n    console.log(&#39;Failed to set uid: &#39; + err);\n  }\n}<\/code><\/pre>\n","p":[{"o":false,"t":"id","d":"","type":""}]},"getgroups":{"y":"process.getgroups()","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified\nif the effective group ID is included but node.js ensures it always is.\n\n\n<\/p>\n","p":[]},"setgroups":{"y":"process.setgroups(groups)","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Sets the supplementary group IDs. This is a privileged operation, meaning you\nneed to be root or have the CAP_SETGID capability.\n\n<\/p>\n<p>The list can contain group IDs, group names or both.\n\n\n<\/p>\n","p":[{"o":false,"t":"groups","d":"","type":""}]},"initgroups":{"y":"process.initgroups(user, extra_group)","s":"<p>Note: this function is only available on POSIX platforms (i.e. not Windows)\n\n<\/p>\n<p>Reads \/etc\/group and initializes the group access list, using all groups of\nwhich the user is a member. This is a privileged operation, meaning you need\nto be root or have the CAP_SETGID capability.\n\n<\/p>\n<p><code>user<\/code> is a user name or user ID. <code>extra_group<\/code> is a group name or group ID.\n\n<\/p>\n<p>Some care needs to be taken when dropping privileges. Example:\n\n<\/p>\n<pre><code>console.log(process.getgroups());         \/\/ [ 0 ]\nprocess.initgroups(&#39;bnoordhuis&#39;, 1000);   \/\/ switch user\nconsole.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     \/\/ drop root gid\nconsole.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000 ]<\/code><\/pre>\n","p":[{"o":false,"t":"user","d":"","type":""},{"o":false,"t":"extra_group","d":"","type":""}]},"kill":{"y":"process.kill(pid, [signal])","s":"<p>Send a signal to a process. <code>pid<\/code> is the process id and <code>signal<\/code> is the\nstring describing the signal to send.  Signal names are strings like\n&#39;SIGINT&#39; or &#39;SIGHUP&#39;.  If omitted, the signal will be &#39;SIGTERM&#39;.\nSee <a href=\"#process_signal_events\">Signal Events<\/a> and kill(2) for more information.\n\n<\/p>\n<p>Will throw an error if target does not exist, and as a special case, a signal of\n<code>0<\/code> can be used to test for the existence of a process.\n\n<\/p>\n<p>Note that just because the name of this function is <code>process.kill<\/code>, it is\nreally just a signal sender, like the <code>kill<\/code> system call.  The signal sent\nmay do something other than kill the target process.\n\n<\/p>\n<p>Example of sending a signal to yourself:\n\n<\/p>\n<pre><code>process.on(&#39;SIGHUP&#39;, function() {\n  console.log(&#39;Got SIGHUP signal.&#39;);\n});\n\nsetTimeout(function() {\n  console.log(&#39;Exiting.&#39;);\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, &#39;SIGHUP&#39;);<\/code><\/pre>\n<p>Note: When SIGUSR1 is received by Node.js it starts the debugger, see\n<a href=\"#process_signal_events\">Signal Events<\/a>.\n\n<\/p>\n","p":[{"o":false,"t":"pid","d":"","type":""},{"o":true,"t":"signal","d":"","type":""}]},"memoryUsage":{"y":"process.memoryUsage()","s":"<p>Returns an object describing the memory usage of the Node process\nmeasured in bytes.\n\n<\/p>\n<pre><code>var util = require(&#39;util&#39;);\n\nconsole.log(util.inspect(process.memoryUsage()));<\/code><\/pre>\n<p>This will generate:\n\n<\/p>\n<pre><code>{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }<\/code><\/pre>\n<p><code>heapTotal<\/code> and <code>heapUsed<\/code> refer to V8&#39;s memory usage.\n\n\n<\/p>\n","p":[]},"nextTick":{"y":"process.nextTick(callback)","s":"<p>On the next loop around the event loop call this callback.\nThis is <em>not<\/em> a simple alias to <code>setTimeout(fn, 0)<\/code>, it&#39;s much more\nefficient.  It typically runs before any other I\/O events fire, but there\nare some exceptions.  See <code>process.maxTickDepth<\/code> below.\n\n<\/p>\n<pre><code>process.nextTick(function() {\n  console.log(&#39;nextTick callback&#39;);\n});<\/code><\/pre>\n<p>This is important in developing APIs where you want to give the user the\nchance to assign event handlers after an object has been constructed,\nbut before any I\/O has occurred.\n\n<\/p>\n<pre><code>function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(function() {\n    this.startDoingStuff();\n  }.bind(this));\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n\/\/ thing.startDoingStuff() gets called now, not before.<\/code><\/pre>\n<p>It is very important for APIs to be either 100% synchronous or 100%\nasynchronous.  Consider this example:\n\n<\/p>\n<pre><code>\/\/ WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}<\/code><\/pre>\n<p>This API is hazardous.  If you do this:\n\n<\/p>\n<pre><code>maybeSync(true, function() {\n  foo();\n});\nbar();<\/code><\/pre>\n<p>then it&#39;s not clear whether <code>foo()<\/code> or <code>bar()<\/code> will be called first.\n\n<\/p>\n<p>This approach is much better:\n\n<\/p>\n<pre><code>function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat(&#39;file&#39;, cb);\n}<\/code><\/pre>\n","p":[{"o":false,"t":"callback","d":"","type":""}]},"umask":{"y":"process.umask([mask])","s":"<p>Sets or reads the process&#39;s file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if <code>mask<\/code> argument is\ngiven, otherwise returns the current mask.\n\n<\/p>\n<pre><code>var oldmask, newmask = 0644;\n\noldmask = process.umask(newmask);\nconsole.log(&#39;Changed umask from: &#39; + oldmask.toString(8) +\n            &#39; to &#39; + newmask.toString(8));<\/code><\/pre>\n","p":[{"o":true,"t":"mask","d":"","type":""}]},"uptime":{"y":"process.uptime()","s":"<p>Number of seconds Node has been running.\n\n\n<\/p>\n","p":[]},"hrtime":{"y":"process.hrtime()","s":"<p>Returns the current high-resolution real time in a <code>[seconds, nanoseconds]<\/code>\ntuple Array. It is relative to an arbitrary time in the past. It is not\nrelated to the time of day and therefore not subject to clock drift. The\nprimary use is for measuring performance between intervals.\n\n<\/p>\n<p>You may pass in the result of a previous call to <code>process.hrtime()<\/code> to get\na diff reading, useful for benchmarks and measuring intervals:\n\n<\/p>\n<pre><code>var time = process.hrtime();\n\/\/ [ 1800216, 25 ]\n\nsetTimeout(function() {\n  var diff = process.hrtime(time);\n  \/\/ [ 1, 552 ]\n\n  console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);\n  \/\/ benchmark took 1000000527 nanoseconds\n}, 1000);<\/code><\/pre>\n","p":[]}}
