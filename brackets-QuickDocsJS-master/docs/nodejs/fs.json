{"rename":{"y":"fs.rename(oldPath, newPath, callback)","s":"<p>Asynchronous rename(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"oldPath","d":"","type":""},{"o":false,"t":"newPath","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"renameSync":{"y":"fs.renameSync(oldPath, newPath)","s":"<p>Synchronous rename(2).\n\n<\/p>\n","p":[{"o":false,"t":"oldPath","d":"","type":""},{"o":false,"t":"newPath","d":"","type":""}]},"ftruncate":{"y":"fs.ftruncate(fd, len, callback)","s":"<p>Asynchronous ftruncate(2). No arguments other than a possible exception are\ngiven to the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"len","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"ftruncateSync":{"y":"fs.ftruncateSync(fd, len)","s":"<p>Synchronous ftruncate(2).\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"len","d":"","type":""}]},"truncate":{"y":"fs.truncate(path, len, callback)","s":"<p>Asynchronous truncate(2). No arguments other than a possible exception are\ngiven to the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"len","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"truncateSync":{"y":"fs.truncateSync(path, len)","s":"<p>Synchronous truncate(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"len","d":"","type":""}]},"chown":{"y":"fs.chown(path, uid, gid, callback)","s":"<p>Asynchronous chown(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"chownSync":{"y":"fs.chownSync(path, uid, gid)","s":"<p>Synchronous chown(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""}]},"fchown":{"y":"fs.fchown(fd, uid, gid, callback)","s":"<p>Asynchronous fchown(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"fchownSync":{"y":"fs.fchownSync(fd, uid, gid)","s":"<p>Synchronous fchown(2).\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""}]},"lchown":{"y":"fs.lchown(path, uid, gid, callback)","s":"<p>Asynchronous lchown(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"lchownSync":{"y":"fs.lchownSync(path, uid, gid)","s":"<p>Synchronous lchown(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"uid","d":"","type":""},{"o":false,"t":"gid","d":"","type":""}]},"chmod":{"y":"fs.chmod(path, mode, callback)","s":"<p>Asynchronous chmod(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"mode","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"chmodSync":{"y":"fs.chmodSync(path, mode)","s":"<p>Synchronous chmod(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"mode","d":"","type":""}]},"fchmod":{"y":"fs.fchmod(fd, mode, callback)","s":"<p>Asynchronous fchmod(2). No arguments other than a possible exception\nare given to the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"mode","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"fchmodSync":{"y":"fs.fchmodSync(fd, mode)","s":"<p>Synchronous fchmod(2).\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"mode","d":"","type":""}]},"lchmod":{"y":"fs.lchmod(path, mode, callback)","s":"<p>Asynchronous lchmod(2). No arguments other than a possible exception\nare given to the completion callback.\n\n<\/p>\n<p>Only available on Mac OS X.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"mode","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"lchmodSync":{"y":"fs.lchmodSync(path, mode)","s":"<p>Synchronous lchmod(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"mode","d":"","type":""}]},"stat":{"y":"fs.stat(path, callback)","s":"<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)<\/code> where\n<code>stats<\/code> is a <a href=\"#fs_class_fs_stats\">fs.Stats<\/a> object.  See the <a href=\"#fs_class_fs_stats\">fs.Stats<\/a>\nsection below for more information.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"lstat":{"y":"fs.lstat(path, callback)","s":"<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)<\/code> where\n<code>stats<\/code> is a <code>fs.Stats<\/code> object. <code>lstat()<\/code> is identical to <code>stat()<\/code>, except that if\n<code>path<\/code> is a symbolic link, then the link itself is stat-ed, not the file that it\nrefers to.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"fstat":{"y":"fs.fstat(fd, callback)","s":"<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)<\/code> where\n<code>stats<\/code> is a <code>fs.Stats<\/code> object. <code>fstat()<\/code> is identical to <code>stat()<\/code>, except that\nthe file to be stat-ed is specified by the file descriptor <code>fd<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"statSync":{"y":"fs.statSync(path)","s":"<p>Synchronous stat(2). Returns an instance of <code>fs.Stats<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"lstatSync":{"y":"fs.lstatSync(path)","s":"<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"fstatSync":{"y":"fs.fstatSync(fd)","s":"<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""}]},"link":{"y":"fs.link(srcpath, dstpath, callback)","s":"<p>Asynchronous link(2). No arguments other than a possible exception are given to\nthe completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"srcpath","d":"","type":""},{"o":false,"t":"dstpath","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"linkSync":{"y":"fs.linkSync(srcpath, dstpath)","s":"<p>Synchronous link(2).\n\n<\/p>\n","p":[{"o":false,"t":"srcpath","d":"","type":""},{"o":false,"t":"dstpath","d":"","type":""}]},"symlink":{"y":"fs.symlink(srcpath, dstpath, [type], callback)","s":"<p>Asynchronous symlink(2). No arguments other than a possible exception are given\nto the completion callback.\nThe <code>type<\/code> argument can be set to <code>&#39;dir&#39;<\/code>, <code>&#39;file&#39;<\/code>, or <code>&#39;junction&#39;<\/code> (default\nis <code>&#39;file&#39;<\/code>) and is only available on Windows (ignored on other platforms).\nNote that Windows junction points require the destination path to be absolute.  When using\n<code>&#39;junction&#39;<\/code>, the <code>destination<\/code> argument will automatically be normalized to absolute path.\n\n<\/p>\n","p":[{"o":false,"t":"srcpath","d":"","type":""},{"o":false,"t":"dstpath","d":"","type":""},{"o":true,"t":"type","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"symlinkSync":{"y":"fs.symlinkSync(srcpath, dstpath, [type])","s":"<p>Synchronous symlink(2).\n\n<\/p>\n","p":[{"o":false,"t":"srcpath","d":"","type":""},{"o":false,"t":"dstpath","d":"","type":""},{"o":true,"t":"type","d":"","type":""}]},"readlink":{"y":"fs.readlink(path, callback)","s":"<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,\nlinkString)<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"readlinkSync":{"y":"fs.readlinkSync(path)","s":"<p>Synchronous readlink(2). Returns the symbolic link&#39;s string value.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"realpath":{"y":"fs.realpath(path, [cache], callback)","s":"<p>Asynchronous realpath(2). The <code>callback<\/code> gets two arguments <code>(err,\nresolvedPath)<\/code>. May use <code>process.cwd<\/code> to resolve relative paths. <code>cache<\/code> is an\nobject literal of mapped paths that can be used to force a specific path\nresolution or avoid additional <code>fs.stat<\/code> calls for known real paths.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>var cache = {&#39;\/etc&#39;:&#39;\/private\/etc&#39;};\nfs.realpath(&#39;\/etc\/passwd&#39;, cache, function (err, resolvedPath) {\n  if (err) throw err;\n  console.log(resolvedPath);\n});<\/code><\/pre>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"cache","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"realpathSync":{"y":"fs.realpathSync(path, [cache])","s":"<p>Synchronous realpath(2). Returns the resolved path.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"cache","d":"","type":""}]},"unlink":{"y":"fs.unlink(path, callback)","s":"<p>Asynchronous unlink(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"unlinkSync":{"y":"fs.unlinkSync(path)","s":"<p>Synchronous unlink(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"rmdir":{"y":"fs.rmdir(path, callback)","s":"<p>Asynchronous rmdir(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"rmdirSync":{"y":"fs.rmdirSync(path)","s":"<p>Synchronous rmdir(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"mkdir":{"y":"fs.mkdir(path, [mode], callback)","s":"<p>Asynchronous mkdir(2). No arguments other than a possible exception are given\nto the completion callback. <code>mode<\/code> defaults to <code>0777<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"mode","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"mkdirSync":{"y":"fs.mkdirSync(path, [mode])","s":"<p>Synchronous mkdir(2).\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"mode","d":"","type":""}]},"readdir":{"y":"fs.readdir(path, callback)","s":"<p>Asynchronous readdir(3).  Reads the contents of a directory.\nThe callback gets two arguments <code>(err, files)<\/code> where <code>files<\/code> is an array of\nthe names of the files in the directory excluding <code>&#39;.&#39;<\/code> and <code>&#39;..&#39;<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"readdirSync":{"y":"fs.readdirSync(path)","s":"<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&#39;.&#39;<\/code> and\n<code>&#39;..&#39;<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"close":{"y":"fs.close(fd, callback)","s":"<p>Asynchronous close(2).  No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"closeSync":{"y":"fs.closeSync(fd)","s":"<p>Synchronous close(2).\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""}]},"open":{"y":"fs.open(path, flags, [mode], callback)","s":"<p>Asynchronous file open. See open(2). <code>flags<\/code> can be:\n\n<\/p>\n<ul>\n<li><p><code>&#39;r&#39;<\/code> - Open file for reading.\nAn exception occurs if the file does not exist.<\/p>\n<\/li>\n<li><p><code>&#39;r+&#39;<\/code> - Open file for reading and writing.\nAn exception occurs if the file does not exist.<\/p>\n<\/li>\n<li><p><code>&#39;rs&#39;<\/code> - Open file for reading in synchronous mode. Instructs the operating\nsystem to bypass the local file system cache.<\/p>\n<p>This is primarily useful for opening files on NFS mounts as it allows you to\nskip the potentially stale local cache. It has a very real impact on I\/O\nperformance so don&#39;t use this flag unless you need it.<\/p>\n<p>Note that this doesn&#39;t turn <code>fs.open()<\/code> into a synchronous blocking call.\nIf that&#39;s what you want then you should be using <code>fs.openSync()<\/code><\/p>\n<\/li>\n<li><p><code>&#39;rs+&#39;<\/code> - Open file for reading and writing, telling the OS to open it\nsynchronously. See notes for <code>&#39;rs&#39;<\/code> about using this with caution.<\/p>\n<\/li>\n<li><p><code>&#39;w&#39;<\/code> - Open file for writing.\nThe file is created (if it does not exist) or truncated (if it exists).<\/p>\n<\/li>\n<li><p><code>&#39;wx&#39;<\/code> - Like <code>&#39;w&#39;<\/code> but fails if <code>path<\/code> exists.<\/p>\n<\/li>\n<li><p><code>&#39;w+&#39;<\/code> - Open file for reading and writing.\nThe file is created (if it does not exist) or truncated (if it exists).<\/p>\n<\/li>\n<li><p><code>&#39;wx+&#39;<\/code> - Like <code>&#39;w+&#39;<\/code> but fails if <code>path<\/code> exists.<\/p>\n<\/li>\n<li><p><code>&#39;a&#39;<\/code> - Open file for appending.\nThe file is created if it does not exist.<\/p>\n<\/li>\n<li><p><code>&#39;ax&#39;<\/code> - Like <code>&#39;a&#39;<\/code> but fails if <code>path<\/code> exists.<\/p>\n<\/li>\n<li><p><code>&#39;a+&#39;<\/code> - Open file for reading and appending.\nThe file is created if it does not exist.<\/p>\n<\/li>\n<li><p><code>&#39;ax+&#39;<\/code> - Like <code>&#39;a+&#39;<\/code> but fails if <code>path<\/code> exists.<\/p>\n<\/li>\n<\/ul>\n<p><code>mode<\/code> sets the file mode (permission and sticky bits), but only if the file was\ncreated. It defaults to <code>0666<\/code>, readable and writeable.\n\n<\/p>\n<p>The callback gets two arguments <code>(err, fd)<\/code>.\n\n<\/p>\n<p>The exclusive flag <code>&#39;x&#39;<\/code> (<code>O_EXCL<\/code> flag in open(2)) ensures that <code>path<\/code> is newly\ncreated. On POSIX systems, <code>path<\/code> is considered to exist even if it is a symlink\nto a non-existent file. The exclusive flag may or may not work with network file\nsystems.\n\n<\/p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"flags","d":"","type":""},{"o":true,"t":"mode","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"openSync":{"y":"fs.openSync(path, flags, [mode])","s":"<p>Synchronous version of <code>fs.open()<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"flags","d":"","type":""},{"o":true,"t":"mode","d":"","type":""}]},"utimes":{"y":"fs.utimes(path, atime, mtime, callback)","s":"<p>Change file timestamps of the file referenced by the supplied path.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"atime","d":"","type":""},{"o":false,"t":"mtime","d":"","type":""}]},"utimesSync":{"y":"fs.utimesSync(path, atime, mtime)","s":"<p>Change file timestamps of the file referenced by the supplied path.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"atime","d":"","type":""},{"o":false,"t":"mtime","d":"","type":""}]},"futimes":{"y":"fs.futimes(fd, atime, mtime, callback)","s":"<p>Change the file timestamps of a file referenced by the supplied file\ndescriptor.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"atime","d":"","type":""},{"o":false,"t":"mtime","d":"","type":""}]},"futimesSync":{"y":"fs.futimesSync(fd, atime, mtime)","s":"<p>Change the file timestamps of a file referenced by the supplied file\ndescriptor.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"atime","d":"","type":""},{"o":false,"t":"mtime","d":"","type":""}]},"fsync":{"y":"fs.fsync(fd, callback)","s":"<p>Asynchronous fsync(2). No arguments other than a possible exception are given\nto the completion callback.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"fsyncSync":{"y":"fs.fsyncSync(fd)","s":"<p>Synchronous fsync(2).\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""}]},"write":{"y":"fs.write(fd, buffer, offset, length, position, callback)","s":"<p>Write <code>buffer<\/code> to the file specified by <code>fd<\/code>.\n\n<\/p>\n<p><code>offset<\/code> and <code>length<\/code> determine the part of the buffer to be written.\n\n<\/p>\n<p><code>position<\/code> refers to the offset from the beginning of the file where this data\nshould be written. If <code>position<\/code> is <code>null<\/code>, the data will be written at the\ncurrent position.\nSee pwrite(2).\n\n<\/p>\n<p>The callback will be given three arguments <code>(err, written, buffer)<\/code> where <code>written<\/code>\nspecifies how many <em>bytes<\/em> were written from <code>buffer<\/code>.\n\n<\/p>\n<p>Note that it is unsafe to use <code>fs.write<\/code> multiple times on the same file\nwithout waiting for the callback. For this scenario,\n<code>fs.createWriteStream<\/code> is strongly recommended.\n\n<\/p>\n<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"buffer","d":"","type":""},{"o":false,"t":"offset","d":"","type":""},{"o":false,"t":"length","d":"","type":""},{"o":false,"t":"position","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"writeSync":{"y":"fs.writeSync(fd, buffer, offset, length, position)","s":"<p>Synchronous version of <code>fs.write()<\/code>. Returns the number of bytes written.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"buffer","d":"","type":""},{"o":false,"t":"offset","d":"","type":""},{"o":false,"t":"length","d":"","type":""},{"o":false,"t":"position","d":"","type":""}]},"read":{"y":"fs.read(fd, buffer, offset, length, position, callback)","s":"<p>Read data from the file specified by <code>fd<\/code>.\n\n<\/p>\n<p><code>buffer<\/code> is the buffer that the data will be written to.\n\n<\/p>\n<p><code>offset<\/code> is the offset in the buffer to start writing at.\n\n<\/p>\n<p><code>length<\/code> is an integer specifying the number of bytes to read.\n\n<\/p>\n<p><code>position<\/code> is an integer specifying where to begin reading from in the file.\nIf <code>position<\/code> is <code>null<\/code>, data will be read from the current file position.\n\n<\/p>\n<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"buffer","d":"","type":""},{"o":false,"t":"offset","d":"","type":""},{"o":false,"t":"length","d":"","type":""},{"o":false,"t":"position","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"readSync":{"y":"fs.readSync(fd, buffer, offset, length, position)","s":"<p>Synchronous version of <code>fs.read<\/code>. Returns the number of <code>bytesRead<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"fd","d":"","type":""},{"o":false,"t":"buffer","d":"","type":""},{"o":false,"t":"offset","d":"","type":""},{"o":false,"t":"length","d":"","type":""},{"o":false,"t":"position","d":"","type":""}]},"readFile":{"y":"fs.readFile(filename, [options], callback)","s":"<p>Asynchronously reads the entire contents of a file. Example:\n\n<\/p>\n<pre><code>fs.readFile(&#39;\/etc\/passwd&#39;, function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});<\/code><\/pre>\n<p>The callback is passed two arguments <code>(err, data)<\/code>, where <code>data<\/code> is the\ncontents of the file.\n\n<\/p>\n<p>If no encoding is specified, then the raw buffer is returned.\n\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":"String"},{"o":true,"t":"options","d":"","type":"Object"},{"o":false,"t":"callback","d":"","type":"Function"}]},"readFileSync":{"y":"fs.readFileSync(filename, [options])","s":"<p>Synchronous version of <code>fs.readFile<\/code>. Returns the contents of the <code>filename<\/code>.\n\n<\/p>\n<p>If the <code>encoding<\/code> option is specified then this function returns a\nstring. Otherwise it returns a buffer.\n\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":true,"t":"options","d":"","type":""}]},"writeFile":{"y":"fs.writeFile(filename, data, [options], callback)","s":"<p>Asynchronously writes data to a file, replacing the file if it already exists.\n<code>data<\/code> can be a string or a buffer.\n\n<\/p>\n<p>The <code>encoding<\/code> option is ignored if <code>data<\/code> is a buffer. It defaults\nto <code>&#39;utf8&#39;<\/code>.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node&#39;, function (err) {\n  if (err) throw err;\n  console.log(&#39;It\\&#39;s saved!&#39;);\n});<\/code><\/pre>\n","p":[{"o":false,"t":"filename","d":"","type":"String"},{"o":false,"t":"data","d":"","type":"String | Buffer"},{"o":true,"t":"options","d":"","type":"Object"},{"o":false,"t":"callback","d":"","type":"Function"}]},"writeFileSync":{"y":"fs.writeFileSync(filename, data, [options])","s":"<p>The synchronous version of <code>fs.writeFile<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":false,"t":"data","d":"","type":""},{"o":true,"t":"options","d":"","type":""}]},"appendFile":{"y":"fs.appendFile(filename, data, [options], callback)","s":"<p>Asynchronously append data to a file, creating the file if it not yet exists.\n<code>data<\/code> can be a string or a buffer.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, function (err) {\n  if (err) throw err;\n  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);\n});<\/code><\/pre>\n","p":[{"o":false,"t":"filename","d":"","type":"String"},{"o":false,"t":"data","d":"","type":"String | Buffer"},{"o":true,"t":"options","d":"","type":"Object"},{"o":false,"t":"callback","d":"","type":"Function"}]},"appendFileSync":{"y":"fs.appendFileSync(filename, data, [options])","s":"<p>The synchronous version of <code>fs.appendFile<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":false,"t":"data","d":"","type":""},{"o":true,"t":"options","d":"","type":""}]},"watchFile":{"y":"fs.watchFile(filename, [options], listener)","s":"<p>Watch for changes on <code>filename<\/code>. The callback <code>listener<\/code> will be called each\ntime the file is accessed.\n\n<\/p>\n<p>The second argument is optional. The <code>options<\/code> if provided should be an object\ncontaining two members a boolean, <code>persistent<\/code>, and <code>interval<\/code>. <code>persistent<\/code>\nindicates whether the process should continue to run as long as files are\nbeing watched. <code>interval<\/code> indicates how often the target should be polled,\nin milliseconds. The default is <code>{ persistent: true, interval: 5007 }<\/code>.\n\n<\/p>\n<p>The <code>listener<\/code> gets two arguments the current stat object and the previous\nstat object:\n\n<\/p>\n<pre><code>fs.watchFile(&#39;message.text&#39;, function (curr, prev) {\n  console.log(&#39;the current mtime is: &#39; + curr.mtime);\n  console.log(&#39;the previous mtime was: &#39; + prev.mtime);\n});<\/code><\/pre>\n<p>These stat objects are instances of <code>fs.Stat<\/code>.\n\n<\/p>\n<p>If you want to be notified when the file was modified, not just accessed\nyou need to compare <code>curr.mtime<\/code> and <code>prev.mtime<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":true,"t":"options","d":"","type":""},{"o":false,"t":"listener","d":"","type":""}]},"unwatchFile":{"y":"fs.unwatchFile(filename, [listener])","s":"<p>Stop watching for changes on <code>filename<\/code>. If <code>listener<\/code> is specified, only that\nparticular listener is removed. Otherwise, <em>all<\/em> listeners are removed and you\nhave effectively stopped watching <code>filename<\/code>.\n\n<\/p>\n<p>Calling <code>fs.unwatchFile()<\/code> with a filename that is not being watched is a\nno-op, not an error.\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":true,"t":"listener","d":"","type":""}]},"watch":{"y":"fs.watch(filename, [options], [listener])","s":"<p>Watch for changes on <code>filename<\/code>, where <code>filename<\/code> is either a file or a\ndirectory.  The returned object is a <a href=\"#fs_class_fs_fswatcher\">fs.FSWatcher<\/a>.\n\n<\/p>\n<p>The second argument is optional. The <code>options<\/code> if provided should be an object\ncontaining a boolean member <code>persistent<\/code>, which indicates whether the process\nshould continue to run as long as files are being watched. The default is\n<code>{ persistent: true }<\/code>.\n\n<\/p>\n<p>The listener callback gets two arguments <code>(event, filename)<\/code>.  <code>event<\/code> is either\n&#39;rename&#39; or &#39;change&#39;, and <code>filename<\/code> is the name of the file which triggered\nthe event.\n\n<\/p>\n","p":[{"o":false,"t":"filename","d":"","type":""},{"o":true,"t":"options","d":"","type":""},{"o":true,"t":"listener","d":"","type":""}]},"exists":{"y":"fs.exists(path, callback)","s":"<p>Test whether or not the given path exists by checking with the file system.\nThen call the <code>callback<\/code> argument with either true or false.  Example:\n\n<\/p>\n<pre><code>fs.exists(&#39;\/etc\/passwd&#39;, function (exists) {\n  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);\n});<\/code><\/pre>\n<p><code>fs.exists()<\/code> is an anachronism and exists only for historical reasons.\nThere should almost never be a reason to use it in your own code.\n\n<\/p>\n<p>In particular, checking if a file exists before opening it is an anti-pattern\nthat leaves you vulnerable to race conditions: another process may remove the\nfile between the calls to <code>fs.exists()<\/code> and <code>fs.open()<\/code>.  Just open the file\nand handle the error when it&#39;s not there.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"existsSync":{"y":"fs.existsSync(path)","s":"<p>Synchronous version of <code>fs.exists<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""}]},"createReadStream":{"y":"fs.createReadStream(path, [options])","s":"<p>Returns a new ReadStream object (See <code>Readable Stream<\/code>).\n\n<\/p>\n<p><code>options<\/code> is an object with the following defaults:\n\n<\/p>\n<pre><code>{ flags: &#39;r&#39;,\n  encoding: null,\n  fd: null,\n  mode: 0666,\n  autoClose: true\n}<\/code><\/pre>\n<p><code>options<\/code> can include <code>start<\/code> and <code>end<\/code> values to read a range of bytes from\nthe file instead of the entire file.  Both <code>start<\/code> and <code>end<\/code> are inclusive and\nstart at 0. The <code>encoding<\/code> can be <code>&#39;utf8&#39;<\/code>, <code>&#39;ascii&#39;<\/code>, or <code>&#39;base64&#39;<\/code>.\n\n<\/p>\n<p>If <code>autoClose<\/code> is false, then the file descriptor won&#39;t be closed, even if\nthere&#39;s an error.  It is your responsiblity to close it and make sure\nthere&#39;s no file descriptor leak.  If <code>autoClose<\/code> is set to true (default\nbehavior), on <code>error<\/code> or <code>end<\/code> the file descriptor will be closed\nautomatically.\n\n<\/p>\n<p>An example to read the last 10 bytes of a file which is 100 bytes long:\n\n<\/p>\n<pre><code>fs.createReadStream(&#39;sample.txt&#39;, {start: 90, end: 99});<\/code><\/pre>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"options","d":"","type":""}]},"createWriteStream":{"y":"fs.createWriteStream(path, [options])","s":"<p>Returns a new WriteStream object (See <code>Writable Stream<\/code>).\n\n<\/p>\n<p><code>options<\/code> is an object with the following defaults:\n\n<\/p>\n<pre><code>{ flags: &#39;w&#39;,\n  encoding: null,\n  mode: 0666 }<\/code><\/pre>\n<p><code>options<\/code> may also include a <code>start<\/code> option to allow writing data at\nsome position past the beginning of the file.  Modifying a file rather\nthan replacing it may require a <code>flags<\/code> mode of <code>r+<\/code> rather than the\ndefault mode <code>w<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"path","d":"","type":""},{"o":true,"t":"options","d":"","type":""}]}}
