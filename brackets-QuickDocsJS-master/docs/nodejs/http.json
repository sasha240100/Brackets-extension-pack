{"createServer":{"y":"http.createServer([requestListener])","s":"<p>Returns a new web server object.\n\n<\/p>\n<p>The <code>requestListener<\/code> is a function which is automatically\nadded to the <code>&#39;request&#39;<\/code> event.\n\n<\/p>\n","p":[{"o":true,"t":"requestListener","d":"","type":""}]},"createClient":{"y":"http.createClient([port], [host])","s":"<p>This function is <strong>deprecated<\/strong>; please use [http.request()][] instead.\nConstructs a new HTTP client. <code>port<\/code> and <code>host<\/code> refer to the server to be\nconnected to.\n\n<\/p>\n","p":[{"o":true,"t":"port","d":"","type":""},{"o":true,"t":"host","d":"","type":""}]},"request":{"y":"http.request(options, [callback])","s":"<p>Node maintains several connections per server to make HTTP requests.\nThis function allows one to transparently issue requests.\n\n<\/p>\n<p><code>options<\/code> can be an object or a string. If <code>options<\/code> is a string, it is\nautomatically parsed with [url.parse()][].\n\n<\/p>\n<p>Options:\n\n<\/p>\n<ul>\n<li><code>host<\/code>: A domain name or IP address of the server to issue the request to.\nDefaults to <code>&#39;localhost&#39;<\/code>.<\/li>\n<li><code>hostname<\/code>: To support <code>url.parse()<\/code> <code>hostname<\/code> is preferred over <code>host<\/code><\/li>\n<li><code>port<\/code>: Port of remote server. Defaults to 80.<\/li>\n<li><code>localAddress<\/code>: Local interface to bind for network connections.<\/li>\n<li><code>socketPath<\/code>: Unix Domain Socket (use one of host:port or socketPath)<\/li>\n<li><code>method<\/code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;<\/code>.<\/li>\n<li><code>path<\/code>: Request path. Defaults to <code>&#39;\/&#39;<\/code>. Should include query string if any.\nE.G. <code>&#39;\/index.html?page=12&#39;<\/code><\/li>\n<li><code>headers<\/code>: An object containing request headers.<\/li>\n<li><code>auth<\/code>: Basic authentication i.e. <code>&#39;user:password&#39;<\/code> to compute an\nAuthorization header.<\/li>\n<li><code>agent<\/code>: Controls [Agent][] behavior. When an Agent is used request will\ndefault to <code>Connection: keep-alive<\/code>. Possible values:<ul>\n<li><code>undefined<\/code> (default): use [global Agent][] for this host and port.<\/li>\n<li><code>Agent<\/code> object: explicitly use the passed in <code>Agent<\/code>.<\/li>\n<li><code>false<\/code>: opts out of connection pooling with an Agent, defaults request to\n<code>Connection: close<\/code>.<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<p>The optional <code>callback<\/code> parameter will be added as a one time listener for\nthe [&#39;response&#39;][] event.\n\n<\/p>\n<p><code>http.request()<\/code> returns an instance of the [http.ClientRequest][]\nclass. The <code>ClientRequest<\/code> instance is a writable stream. If one needs to\nupload a file with a POST request, then write to the <code>ClientRequest<\/code> object.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>var options = {\n  hostname: &#39;www.google.com&#39;,\n  port: 80,\n  path: &#39;\/upload&#39;,\n  method: &#39;POST&#39;\n};\n\nvar req = http.request(options, function(res) {\n  console.log(&#39;STATUS: &#39; + res.statusCode);\n  console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));\n  res.setEncoding(&#39;utf8&#39;);\n  res.on(&#39;data&#39;, function (chunk) {\n    console.log(&#39;BODY: &#39; + chunk);\n  });\n});\n\nreq.on(&#39;error&#39;, function(e) {\n  console.log(&#39;problem with request: &#39; + e.message);\n});\n\n\/\/ write data to request body\nreq.write(&#39;data\\n&#39;);\nreq.write(&#39;data\\n&#39;);\nreq.end();<\/code><\/pre>\n<p>Note that in the example <code>req.end()<\/code> was called. With <code>http.request()<\/code> one\nmust always call <code>req.end()<\/code> to signify that you&#39;re done with the request -\neven if there is no data being written to the request body.\n\n<\/p>\n<p>If any error is encountered during the request (be that with DNS resolution,\nTCP level errors, or actual HTTP parse errors) an <code>&#39;error&#39;<\/code> event is emitted\non the returned request object.\n\n<\/p>\n<p>There are a few special headers that should be noted.\n\n<\/p>\n<ul>\n<li><p>Sending a &#39;Connection: keep-alive&#39; will notify Node that the connection to\nthe server should be persisted until the next request.<\/p>\n<\/li>\n<li><p>Sending a &#39;Content-length&#39; header will disable the default chunked encoding.<\/p>\n<\/li>\n<li><p>Sending an &#39;Expect&#39; header will immediately send the request headers.\nUsually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout\nand listen for the <code>continue<\/code> event. See RFC2616 Section 8.2.3 for more\ninformation.<\/p>\n<\/li>\n<li><p>Sending an Authorization header will override using the <code>auth<\/code> option\nto compute basic authentication.<\/p>\n<\/li>\n<\/ul>\n","p":[{"o":false,"t":"options","d":"","type":""},{"o":true,"t":"callback","d":"","type":""}]},"get":{"y":"http.get(options, [callback])","s":"<p>Since most requests are GET requests without bodies, Node provides this\nconvenience method. The only difference between this method and <code>http.request()<\/code>\nis that it sets the method to GET and calls <code>req.end()<\/code> automatically.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>http.get(&quot;http:\/\/www.google.com\/index.html&quot;, function(res) {\n  console.log(&quot;Got response: &quot; + res.statusCode);\n}).on(&#39;error&#39;, function(e) {\n  console.log(&quot;Got error: &quot; + e.message);\n});<\/code><\/pre>\n","p":[{"o":false,"t":"options","d":"","type":""},{"o":true,"t":"callback","d":"","type":""}]}}
