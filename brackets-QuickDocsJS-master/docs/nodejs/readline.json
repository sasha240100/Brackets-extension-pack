{"createInterface":{"y":"readline.createInterface(options)","s":"<p>Creates a readline <code>Interface<\/code> instance. Accepts an &quot;options&quot; Object that takes\nthe following values:\n\n<\/p>\n<ul>\n<li><p><code>input<\/code> - the readable stream to listen to (Required).<\/p>\n<\/li>\n<li><p><code>output<\/code> - the writable stream to write readline data to (Required).<\/p>\n<\/li>\n<li><p><code>completer<\/code> - an optional function that is used for Tab autocompletion. See\nbelow for an example of using this.<\/p>\n<\/li>\n<li><p><code>terminal<\/code> - pass <code>true<\/code> if the <code>input<\/code> and <code>output<\/code> streams should be\ntreated like a TTY, and have ANSI\/VT100 escape codes written to it.\nDefaults to checking <code>isTTY<\/code> on the <code>output<\/code> stream upon instantiation.<\/p>\n<\/li>\n<\/ul>\n<p>The <code>completer<\/code> function is given the current line entered by the user, and\nis supposed to return an Array with 2 entries:\n\n<\/p>\n<ol>\n<li><p>An Array with matching entries for the completion.<\/p>\n<\/li>\n<li><p>The substring that was used for the matching.<\/p>\n<\/li>\n<\/ol>\n<p>Which ends up looking something like:\n<code>[[substr1, substr2, ...], originalsubstring]<\/code>.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>function completer(line) {\n  var completions = &#39;.help .error .exit .quit .q&#39;.split(&#39; &#39;)\n  var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })\n  \/\/ show all completions if none found\n  return [hits.length ? hits : completions, line]\n}<\/code><\/pre>\n<p>Also <code>completer<\/code> can be run in async mode if it accepts two arguments:\n\n<\/p>\n<pre><code>function completer(linePartial, callback) {\n  callback(null, [[&#39;123&#39;], linePartial]);\n}<\/code><\/pre>\n<p><code>createInterface<\/code> is commonly used with <code>process.stdin<\/code> and\n<code>process.stdout<\/code> in order to accept user input:\n\n<\/p>\n<pre><code>var readline = require(&#39;readline&#39;);\nvar rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});<\/code><\/pre>\n<p>Once you have a readline instance, you most commonly listen for the\n<code>&quot;line&quot;<\/code> event.\n\n<\/p>\n<p>If <code>terminal<\/code> is <code>true<\/code> for this instance then the <code>output<\/code> stream will get\nthe best compatibility if it defines an <code>output.columns<\/code> property, and fires\na <code>&quot;resize&quot;<\/code> event on the <code>output<\/code> if\/when the columns ever change\n(<code>process.stdout<\/code> does this automatically when it is a TTY).\n\n<\/p>\n","p":[{"o":false,"t":"options","d":"","type":""}]},"cursorTo":{"y":"readline.cursorTo(stream, x, y)","s":"<p>Move cursor to the specified position in a given TTY stream.\n\n<\/p>\n","p":[{"o":false,"t":"stream","d":"","type":""},{"o":false,"t":"x","d":"","type":""},{"o":false,"t":"y","d":"","type":""}]},"moveCursor":{"y":"readline.moveCursor(stream, dx, dy)","s":"<p>Move cursor relative to it&#39;s current position in a given TTY stream.\n\n<\/p>\n","p":[{"o":false,"t":"stream","d":"","type":""},{"o":false,"t":"dx","d":"","type":""},{"o":false,"t":"dy","d":"","type":""}]},"clearLine":{"y":"readline.clearLine(stream, dir)","s":"<p>Clears current line of given TTY stream in a specified direction.\n<code>dir<\/code> should have one of following values:\n\n<\/p>\n<ul>\n<li><code>-1<\/code> - to the left from cursor<\/li>\n<li><code>1<\/code> - to the right from cursor<\/li>\n<li><code>0<\/code> - the entire line<\/li>\n<\/ul>\n","p":[{"o":false,"t":"stream","d":"","type":""},{"o":false,"t":"dir","d":"","type":""}]},"clearScreenDown":{"y":"readline.clearScreenDown(stream)","s":"<p>Clears the screen from the current position of the cursor down.\n<\/p>\n","p":[{"o":false,"t":"stream","d":"","type":""}]}}
