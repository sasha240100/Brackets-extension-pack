{"spawn":{"y":"child_process.spawn(command, [args], [options])","s":"<p>Launches a new process with the given <code>command<\/code>, with  command line arguments in <code>args<\/code>.\nIf omitted, <code>args<\/code> defaults to an empty Array.\n\n<\/p>\n<p>The third argument is used to specify additional options, which defaults to:\n\n<\/p>\n<pre><code>{ cwd: undefined,\n  env: process.env\n}<\/code><\/pre>\n<p><code>cwd<\/code> allows you to specify the working directory from which the process is spawned.\nUse <code>env<\/code> to specify environment variables that will be visible to the new process.\n\n<\/p>\n<p>Example of running <code>ls -lh \/usr<\/code>, capturing <code>stdout<\/code>, <code>stderr<\/code>, and the exit code:\n\n<\/p>\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\n    ls    = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;\/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, function (data) {\n  console.log(&#39;stdout: &#39; + data);\n});\n\nls.stderr.on(&#39;data&#39;, function (data) {\n  console.log(&#39;stderr: &#39; + data);\n});\n\nls.on(&#39;close&#39;, function (code) {\n  console.log(&#39;child process exited with code &#39; + code);\n});<\/code><\/pre>\n<p>Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;\n\n<\/p>\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\n    ps    = spawn(&#39;ps&#39;, [&#39;ax&#39;]),\n    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\nps.stdout.on(&#39;data&#39;, function (data) {\n  grep.stdin.write(data);\n});\n\nps.stderr.on(&#39;data&#39;, function (data) {\n  console.log(&#39;ps stderr: &#39; + data);\n});\n\nps.on(&#39;close&#39;, function (code) {\n  if (code !== 0) {\n    console.log(&#39;ps process exited with code &#39; + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(&#39;data&#39;, function (data) {\n  console.log(&#39;&#39; + data);\n});\n\ngrep.stderr.on(&#39;data&#39;, function (data) {\n  console.log(&#39;grep stderr: &#39; + data);\n});\n\ngrep.on(&#39;close&#39;, function (code) {\n  if (code !== 0) {\n    console.log(&#39;grep process exited with code &#39; + code);\n  }\n});<\/code><\/pre>\n<p>Example of checking for failed exec:\n\n<\/p>\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\n    child = spawn(&#39;bad_command&#39;);\n\nchild.stderr.setEncoding(&#39;utf8&#39;);\nchild.stderr.on(&#39;data&#39;, function (data) {\n  if (\/^execvp\\(\\)\/.test(data)) {\n    console.log(&#39;Failed to start child process.&#39;);\n  }\n});<\/code><\/pre>\n<p>Note that if spawn receives an empty options object, it will result in\nspawning the process with an empty environment rather than using\n<code>process.env<\/code>. This due to backwards compatibility issues with a deprecated\nAPI.\n\n<\/p>\n<p>The &#39;stdio&#39; option to <code>child_process.spawn()<\/code> is an array where each\nindex corresponds to a fd in the child.  The value is one of the following:\n\n<\/p>\n<ol>\n<li><code>&#39;pipe&#39;<\/code> - Create a pipe between the child process and the parent process.\nThe parent end of the pipe is exposed to the parent as a property on the\n<code>child_process<\/code> object as <code>ChildProcess.stdio[fd]<\/code>. Pipes created for\nfds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout\nand ChildProcess.stderr, respectively.<\/li>\n<li><code>&#39;ipc&#39;<\/code> - Create an IPC channel for passing messages\/file descriptors\nbetween parent and child. A ChildProcess may have at most <em>one<\/em> IPC stdio\nfile descriptor. Setting this option enables the ChildProcess.send() method.\nIf the child writes JSON messages to this file descriptor, then this will\ntrigger ChildProcess.on(&#39;message&#39;).  If the child is a Node.js program, then\nthe presence of an IPC channel will enable process.send() and\nprocess.on(&#39;message&#39;).<\/li>\n<li><code>&#39;ignore&#39;<\/code> - Do not set this file descriptor in the child. Note that Node\nwill always open fd 0 - 2 for the processes it spawns. When any of these is\nignored node will open <code>\/dev\/null<\/code> and attach it to the child&#39;s fd.<\/li>\n<li><code>Stream<\/code> object - Share a readable or writable stream that refers to a tty,\nfile, socket, or a pipe with the child process. The stream&#39;s underlying\nfile descriptor is duplicated in the child process to the fd that \ncorresponds to the index in the <code>stdio<\/code> array. Note that the stream must\nhave an underlying descriptor (file streams do not until the <code>&#39;open&#39;<\/code>\nevent has occurred).<\/li>\n<li>Positive integer - The integer value is interpreted as a file descriptor \nthat is is currently open in the parent process. It is shared with the child\nprocess, similar to how <code>Stream<\/code> objects can be shared.<\/li>\n<li><code>null<\/code>, <code>undefined<\/code> - Use default value. For stdio fds 0, 1 and 2 (in other\nwords, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the\ndefault is <code>&#39;ignore&#39;<\/code>.<\/li>\n<\/ol>\n<p>As a shorthand, the <code>stdio<\/code> argument may also be one of the following\nstrings, rather than an array:\n\n<\/p>\n<ul>\n<li><code>ignore<\/code> - <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]<\/code><\/li>\n<li><code>pipe<\/code> - <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]<\/code><\/li>\n<li><code>inherit<\/code> - <code>[process.stdin, process.stdout, process.stderr]<\/code> or <code>[0,1,2]<\/code><\/li>\n<\/ul>\n<p>Example:\n\n<\/p>\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn;\n\n\/\/ Child will use parent&#39;s stdios\nspawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });\n\n\/\/ Spawn child sharing only stderr\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });\n\n\/\/ Open an extra fd=4, to interact with programs present a\n\/\/ startd-style interface.\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });<\/code><\/pre>\n<p>If the <code>detached<\/code> option is set, the child process will be made the leader of a\nnew process group.  This makes it possible for the child to continue running \nafter the parent exits.\n\n<\/p>\n<p>By default, the parent will wait for the detached child to exit.  To prevent\nthe parent from waiting for a given <code>child<\/code>, use the <code>child.unref()<\/code> method,\nand the parent&#39;s event loop will not include the child in its reference count.\n\n<\/p>\n<p>Example of detaching a long-running process and redirecting its output to a\nfile:\n\n<\/p>\n<pre><code> var fs = require(&#39;fs&#39;),\n     spawn = require(&#39;child_process&#39;).spawn,\n     out = fs.openSync(&#39;.\/out.log&#39;, &#39;a&#39;),\n     err = fs.openSync(&#39;.\/out.log&#39;, &#39;a&#39;);\n\n var child = spawn(&#39;prg&#39;, [], {\n   detached: true,\n   stdio: [ &#39;ignore&#39;, out, err ]\n });\n\n child.unref();<\/code><\/pre>\n<p>When using the <code>detached<\/code> option to start a long-running process, the process\nwill not stay running in the background unless it is provided with a <code>stdio<\/code>\nconfiguration that is not connected to the parent.  If the parent&#39;s <code>stdio<\/code> is\ninherited, the child will remain attached to the controlling terminal.\n\n<\/p>\n<p>There is a deprecated option called <code>customFds<\/code> which allows one to specify\nspecific file descriptors for the stdio of the child process. This API was\nnot portable to all platforms and therefore removed.\nWith <code>customFds<\/code> it was possible to hook up the new process&#39; <code>[stdin, stdout,\nstderr]<\/code> to existing streams; <code>-1<\/code> meant that a new stream should be created.\nUse at your own risk.\n\n<\/p>\n<p>See also: <code>child_process.exec()<\/code> and <code>child_process.fork()<\/code>\n\n<\/p>\n","p":[{"o":false,"t":"command","d":"The command to run","type":"String"},{"o":true,"t":"args","d":"List of string arguments","type":"Array"},{"o":true,"t":"options","d":"","type":"Object"}]},"exec":{"y":"child_process.exec(command, [options], callback)","s":"<p>Runs a command in a shell and buffers the output.\n\n<\/p>\n<pre><code>var exec = require(&#39;child_process&#39;).exec,\n    child;\n\nchild = exec(&#39;cat *.js bad_file | wc -l&#39;,\n  function (error, stdout, stderr) {\n    console.log(&#39;stdout: &#39; + stdout);\n    console.log(&#39;stderr: &#39; + stderr);\n    if (error !== null) {\n      console.log(&#39;exec error: &#39; + error);\n    }\n});<\/code><\/pre>\n<p>The callback gets the arguments <code>(error, stdout, stderr)<\/code>. On success, <code>error<\/code>\nwill be <code>null<\/code>.  On error, <code>error<\/code> will be an instance of <code>Error<\/code> and <code>error.code<\/code>\nwill be the exit code of the child process, and <code>error.signal<\/code> will be set to the\nsignal that terminated the process.\n\n<\/p>\n<p>There is a second optional argument to specify several options. The\ndefault options are\n\n<\/p>\n<pre><code>{ encoding: &#39;utf8&#39;,\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: &#39;SIGTERM&#39;,\n  cwd: null,\n  env: null }<\/code><\/pre>\n<p>If <code>timeout<\/code> is greater than 0, then it will kill the child process\nif it runs longer than <code>timeout<\/code> milliseconds. The child process is killed with\n<code>killSignal<\/code> (default: <code>&#39;SIGTERM&#39;<\/code>). <code>maxBuffer<\/code> specifies the largest\namount of data allowed on stdout or stderr - if this value is exceeded then\nthe child process is killed.\n\n\n<\/p>\n","p":[{"o":false,"t":"command","d":"The command to run, with space-separated arguments","type":"String"},{"o":true,"t":"options","d":"","type":"Object"},{"o":false,"t":"callback","d":"called with the output when process terminates","type":"Function"}]},"execFile":{"y":"child_process.execFile(file, [args], [options], [callback])","s":"<p>This is similar to <code>child_process.exec()<\/code> except it does not execute a\nsubshell but rather the specified file directly. This makes it slightly\nleaner than <code>child_process.exec<\/code>. It has the same options.\n\n\n<\/p>\n","p":[{"o":false,"t":"file","d":"The filename of the program to run","type":"String"},{"o":true,"t":"args","d":"List of string arguments","type":"Array"},{"o":true,"t":"options","d":"","type":"Object"},{"o":true,"t":"callback","d":"called with the output when process terminates","type":"Function"}]},"fork":{"y":"child_process.fork(modulePath, [args], [options])","s":"<p>This is a special case of the <code>spawn()<\/code> functionality for spawning Node\nprocesses. In addition to having all the methods in a normal ChildProcess\ninstance, the returned object has a communication channel built-in. See\n<code>child.send(message, [sendHandle])<\/code> for details.\n\n<\/p>\n<p>These child Nodes are still whole new instances of V8. Assume at least 30ms\nstartup and 10mb memory for each new Node. That is, you cannot create many\nthousands of them.\n\n<\/p>\n<p>The <code>execPath<\/code> property in the <code>options<\/code> object allows for a process to be\ncreated for the child rather than the current <code>node<\/code> executable. This should be\ndone with care and by default will talk over the fd represented an\nenvironmental variable <code>NODE_CHANNEL_FD<\/code> on the child process. The input and\noutput on this fd is expected to be line delimited JSON objects.\n\n<\/p>\n","p":[{"o":false,"t":"modulePath","d":"The module to run in the child","type":"String"},{"o":true,"t":"args","d":"List of string arguments","type":"Array"},{"o":true,"t":"options","d":"","type":"Object"}]}}
