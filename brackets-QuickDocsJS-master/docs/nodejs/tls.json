{"getCiphers":{"y":"tls.getCiphers()","s":"<p>Returns an array with the names of the supported SSL ciphers.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>var ciphers = tls.getCiphers();\nconsole.log(ciphers); \/\/ [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]<\/code><\/pre>\n","p":[]},"createServer":{"y":"tls.createServer(options, [secureConnectionListener])","s":"<p>Creates a new [tls.Server][].  The <code>connectionListener<\/code> argument is\nautomatically set as a listener for the [secureConnection][] event.  The\n<code>options<\/code> object has these possibilities:\n\n<\/p>\n<ul>\n<li><p><code>pfx<\/code>: A string or <code>Buffer<\/code> containing the private key, certificate and\nCA certs of the server in PFX or PKCS12 format. (Mutually exclusive with\nthe <code>key<\/code>, <code>cert<\/code> and <code>ca<\/code> options.)<\/p>\n<\/li>\n<li><p><code>key<\/code>: A string or <code>Buffer<\/code> containing the private key of the server in\nPEM format. (Required)<\/p>\n<\/li>\n<li><p><code>passphrase<\/code>: A string of passphrase for the private key or pfx.<\/p>\n<\/li>\n<li><p><code>cert<\/code>: A string or <code>Buffer<\/code> containing the certificate key of the server in\nPEM format. (Required)<\/p>\n<\/li>\n<li><p><code>ca<\/code>: An array of strings or <code>Buffer<\/code>s of trusted certificates in PEM\nformat. If this is omitted several well known &quot;root&quot; CAs will be used,\nlike VeriSign. These are used to authorize connections.<\/p>\n<\/li>\n<li><p><code>crl<\/code> : Either a string or list of strings of PEM encoded CRLs (Certificate\nRevocation List)<\/p>\n<\/li>\n<li><p><code>ciphers<\/code>: A string describing the ciphers to use or exclude.<\/p>\n<p>To mitigate [BEAST attacks] it is recommended that you use this option in\nconjunction with the <code>honorCipherOrder<\/code> option described below to\nprioritize the non-CBC cipher.<\/p>\n<p>Defaults to <code>AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH<\/code>.\nConsult the [OpenSSL cipher list format documentation] for details on the\nformat. ECDH (Elliptic Curve Diffie-Hellman) ciphers are not yet supported.<\/p>\n<\/li>\n<\/ul>\n<pre><code>`AES128-GCM-SHA256` is used when node.js is linked against OpenSSL 1.0.1\nor newer and the client speaks TLS 1.2, RC4 is used as a secure fallback.\n\n**NOTE**: Previous revisions of this section suggested `AES256-SHA` as an\nacceptable cipher. Unfortunately, `AES256-SHA` is a CBC cipher and therefore\nsusceptible to BEAST attacks. Do *not* use it.<\/code><\/pre>\n<ul>\n<li><p><code>handshakeTimeout<\/code>: Abort the connection if the SSL\/TLS handshake does not\nfinish in this many milliseconds. The default is 120 seconds.<\/p>\n<p>A <code>&#39;clientError&#39;<\/code> is emitted on the <code>tls.Server<\/code> object whenever a handshake\ntimes out.<\/p>\n<\/li>\n<li><p><code>honorCipherOrder<\/code> : When choosing a cipher, use the server&#39;s preferences\ninstead of the client preferences.<\/p>\n<p>Note that if SSLv2 is used, the server will send its list of preferences\nto the client, and the client chooses the cipher.<\/p>\n<p>Although, this option is disabled by default, it is <em>recommended<\/em> that you\nuse this option in conjunction with the <code>ciphers<\/code> option to mitigate\nBEAST attacks.<\/p>\n<\/li>\n<li><p><code>requestCert<\/code>: If <code>true<\/code> the server will request a certificate from\nclients that connect and attempt to verify that certificate. Default:\n<code>false<\/code>.<\/p>\n<\/li>\n<li><p><code>rejectUnauthorized<\/code>: If <code>true<\/code> the server will reject any connection\nwhich is not authorized with the list of supplied CAs. This option only\nhas an effect if <code>requestCert<\/code> is <code>true<\/code>. Default: <code>false<\/code>.<\/p>\n<\/li>\n<li><p><code>NPNProtocols<\/code>: An array or <code>Buffer<\/code> of possible NPN protocols. (Protocols\nshould be ordered by their priority).<\/p>\n<\/li>\n<li><p><code>SNICallback<\/code>: A function that will be called if client supports SNI TLS\nextension. Only one argument will be passed to it: <code>servername<\/code>. And\n<code>SNICallback<\/code> should return SecureContext instance.\n(You can use <code>crypto.createCredentials(...).context<\/code> to get proper\nSecureContext). If <code>SNICallback<\/code> wasn&#39;t provided - default callback with\nhigh-level API will be used (see below).<\/p>\n<\/li>\n<li><p><code>sessionIdContext<\/code>: A string containing a opaque identifier for session\nresumption. If <code>requestCert<\/code> is <code>true<\/code>, the default is MD5 hash value\ngenerated from command-line. Otherwise, the default is not provided.<\/p>\n<\/li>\n<li><p><code>secureProtocol<\/code>: The SSL method to use, e.g. <code>SSLv3_method<\/code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [SSL_METHODS][].<\/p>\n<\/li>\n<\/ul>\n<p>Here is a simple example echo server:\n\n<\/p>\n<pre><code>var tls = require(&#39;tls&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = {\n  key: fs.readFileSync(&#39;server-key.pem&#39;),\n  cert: fs.readFileSync(&#39;server-cert.pem&#39;),\n\n  \/\/ This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n  \/\/ This is necessary only if the client uses the self-signed certificate.\n  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]\n};\n\nvar server = tls.createServer(options, function(cleartextStream) {\n  console.log(&#39;server connected&#39;,\n              cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  cleartextStream.write(&quot;welcome!\\n&quot;);\n  cleartextStream.setEncoding(&#39;utf8&#39;);\n  cleartextStream.pipe(cleartextStream);\n});\nserver.listen(8000, function() {\n  console.log(&#39;server bound&#39;);\n});<\/code><\/pre>\n<p>Or\n\n<\/p>\n<pre><code>var tls = require(&#39;tls&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = {\n  pfx: fs.readFileSync(&#39;server.pfx&#39;),\n\n  \/\/ This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n};\n\nvar server = tls.createServer(options, function(cleartextStream) {\n  console.log(&#39;server connected&#39;,\n              cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  cleartextStream.write(&quot;welcome!\\n&quot;);\n  cleartextStream.setEncoding(&#39;utf8&#39;);\n  cleartextStream.pipe(cleartextStream);\n});\nserver.listen(8000, function() {\n  console.log(&#39;server bound&#39;);\n});<\/code><\/pre>\n<p>You can test this server by connecting to it with <code>openssl s_client<\/code>:\n\n\n<\/p>\n<pre><code>openssl s_client -connect 127.0.0.1:8000<\/code><\/pre>\n","p":[{"o":false,"t":"options","d":"","type":""},{"o":true,"t":"secureConnectionListener","d":"","type":""}]},"connect":{"y":"tls.connect(port, [host], [options], [callback])","s":"<p>Creates a new client connection to the given <code>port<\/code> and <code>host<\/code> (old API) or\n<code>options.port<\/code> and <code>options.host<\/code>. (If <code>host<\/code> is omitted, it defaults to\n<code>localhost<\/code>.) <code>options<\/code> should be an object which specifies:\n\n<\/p>\n<ul>\n<li><p><code>host<\/code>: Host the client should connect to<\/p>\n<\/li>\n<li><p><code>port<\/code>: Port the client should connect to<\/p>\n<\/li>\n<li><p><code>socket<\/code>: Establish secure connection on a given socket rather than\ncreating a new socket. If this option is specified, <code>host<\/code> and <code>port<\/code>\nare ignored.<\/p>\n<\/li>\n<li><p><code>pfx<\/code>: A string or <code>Buffer<\/code> containing the private key, certificate and\nCA certs of the client in PFX or PKCS12 format.<\/p>\n<\/li>\n<li><p><code>key<\/code>: A string or <code>Buffer<\/code> containing the private key of the client in\nPEM format.<\/p>\n<\/li>\n<li><p><code>passphrase<\/code>: A string of passphrase for the private key or pfx.<\/p>\n<\/li>\n<li><p><code>cert<\/code>: A string or <code>Buffer<\/code> containing the certificate key of the client in\nPEM format.<\/p>\n<\/li>\n<li><p><code>ca<\/code>: An array of strings or <code>Buffer<\/code>s of trusted certificates in PEM\nformat. If this is omitted several well known &quot;root&quot; CAs will be used,\nlike VeriSign. These are used to authorize connections.<\/p>\n<\/li>\n<li><p><code>rejectUnauthorized<\/code>: If <code>true<\/code>, the server certificate is verified against\nthe list of supplied CAs. An <code>&#39;error&#39;<\/code> event is emitted if verification\nfails. Default: <code>true<\/code>.<\/p>\n<\/li>\n<li><p><code>NPNProtocols<\/code>: An array of strings or <code>Buffer<\/code>s containing supported NPN\nprotocols. <code>Buffer<\/code>s should have following format: <code>0x05hello0x05world<\/code>,\nwhere first byte is next protocol name&#39;s length. (Passing array should\nusually be much simpler: <code>[&#39;hello&#39;, &#39;world&#39;]<\/code>.)<\/p>\n<\/li>\n<li><p><code>servername<\/code>: Servername for SNI (Server Name Indication) TLS extension.<\/p>\n<\/li>\n<li><p><code>secureProtocol<\/code>: The SSL method to use, e.g. <code>SSLv3_method<\/code> to force\nSSL version 3. The possible values depend on your installation of\nOpenSSL and are defined in the constant [SSL_METHODS][].<\/p>\n<\/li>\n<\/ul>\n<p>The <code>callback<\/code> parameter will be added as a listener for the\n[&#39;secureConnect&#39;][] event.\n\n<\/p>\n<p><code>tls.connect()<\/code> returns a [CleartextStream][] object.\n\n<\/p>\n<p>Here is an example of a client of echo server as described previously:\n\n<\/p>\n<pre><code>var tls = require(&#39;tls&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = {\n  \/\/ These are necessary only if using the client certificate authentication\n  key: fs.readFileSync(&#39;client-key.pem&#39;),\n  cert: fs.readFileSync(&#39;client-cert.pem&#39;),\n\n  \/\/ This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log(&#39;client connected&#39;,\n              cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding(&#39;utf8&#39;);\ncleartextStream.on(&#39;data&#39;, function(data) {\n  console.log(data);\n});\ncleartextStream.on(&#39;end&#39;, function() {\n  server.close();\n});<\/code><\/pre>\n<p>Or\n\n<\/p>\n<pre><code>var tls = require(&#39;tls&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = {\n  pfx: fs.readFileSync(&#39;client.pfx&#39;)\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log(&#39;client connected&#39;,\n              cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding(&#39;utf8&#39;);\ncleartextStream.on(&#39;data&#39;, function(data) {\n  console.log(data);\n});\ncleartextStream.on(&#39;end&#39;, function() {\n  server.close();\n});<\/code><\/pre>\n","p":[{"o":false,"t":"port","d":"","type":""},{"o":true,"t":"host","d":"","type":""},{"o":true,"t":"options","d":"","type":""},{"o":true,"t":"callback","d":"","type":""}]},"createSecurePair":{"y":"tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])","s":"<p>Creates a new secure pair object with two streams, one of which reads\/writes\nencrypted data, and one reads\/writes cleartext data.\nGenerally the encrypted one is piped to\/from an incoming encrypted data stream,\nand the cleartext one is used as a replacement for the initial encrypted stream.\n\n<\/p>\n<ul>\n<li><p><code>credentials<\/code>: A credentials object from crypto.createCredentials( ... )<\/p>\n<\/li>\n<li><p><code>isServer<\/code>: A boolean indicating whether this tls connection should be\nopened as a server or a client.<\/p>\n<\/li>\n<li><p><code>requestCert<\/code>: A boolean indicating whether a server should request a\ncertificate from a connecting client. Only applies to server connections.<\/p>\n<\/li>\n<li><p><code>rejectUnauthorized<\/code>: A boolean indicating whether a server should\nautomatically reject clients with invalid certificates. Only applies to\nservers with <code>requestCert<\/code> enabled.<\/p>\n<\/li>\n<\/ul>\n<p><code>tls.createSecurePair()<\/code> returns a SecurePair object with [cleartext][] and\n<code>encrypted<\/code> stream properties.\n\n<\/p>\n","p":[{"o":true,"t":"credentials","d":"","type":""},{"o":true,"t":"isServer","d":"","type":""},{"o":true,"t":"requestCert","d":"","type":""},{"o":true,"t":"rejectUnauthorized","d":"","type":""}]}}
