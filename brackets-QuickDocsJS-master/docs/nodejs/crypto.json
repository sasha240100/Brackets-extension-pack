{"getCiphers":{"y":"crypto.getCiphers()","s":"<p>Returns an array with the names of the supported ciphers.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>var ciphers = crypto.getCiphers();\nconsole.log(ciphers); \/\/ [&#39;AES-128-CBC&#39;, &#39;AES-128-CBC-HMAC-SHA1&#39;, ...]<\/code><\/pre>\n","p":[]},"getHashes":{"y":"crypto.getHashes()","s":"<p>Returns an array with the names of the supported hash algorithms.\n\n<\/p>\n<p>Example:\n\n<\/p>\n<pre><code>var hashes = crypto.getHashes();\nconsole.log(hashes); \/\/ [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]<\/code><\/pre>\n","p":[]},"createCredentials":{"y":"crypto.createCredentials(details)","s":"<p>Creates a credentials object, with the optional details being a\ndictionary with keys:\n\n<\/p>\n<ul>\n<li><code>pfx<\/code> : A string or buffer holding the PFX or PKCS12 encoded private\nkey, certificate and CA certificates<\/li>\n<li><code>key<\/code> : A string holding the PEM encoded private key<\/li>\n<li><code>passphrase<\/code> : A string of passphrase for the private key or pfx<\/li>\n<li><code>cert<\/code> : A string holding the PEM encoded certificate<\/li>\n<li><code>ca<\/code> : Either a string or list of strings of PEM encoded CA\ncertificates to trust.<\/li>\n<li><code>crl<\/code> : Either a string or list of strings of PEM encoded CRLs\n(Certificate Revocation List)<\/li>\n<li><code>ciphers<\/code>: A string describing the ciphers to use or exclude.\nConsult\n<a href=\"http:\/\/www.openssl.org\/docs\/apps\/ciphers.html#CIPHER_LIST_FORMAT\">http:\/\/www.openssl.org\/docs\/apps\/ciphers.html#CIPHER_LIST_FORMAT<\/a>\nfor details on the format.<\/li>\n<\/ul>\n<p>If no &#39;ca&#39; details are given, then node.js will use the default\npublicly trusted list of CAs as given in\n<\/p>\n<p><a href=\"http:\/\/mxr.mozilla.org\/mozilla\/source\/security\/nss\/lib\/ckfw\/builtins\/certdata.txt\">http:\/\/mxr.mozilla.org\/mozilla\/source\/security\/nss\/lib\/ckfw\/builtins\/certdata.txt<\/a>.\n\n\n<\/p>\n","p":[{"o":false,"t":"details","d":"","type":""}]},"createHash":{"y":"crypto.createHash(algorithm)","s":"<p>Creates and returns a hash object, a cryptographic hash with the given\nalgorithm which can be used to generate hash digests.\n\n<\/p>\n<p><code>algorithm<\/code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&#39;sha1&#39;<\/code>, <code>&#39;md5&#39;<\/code>,\n<code>&#39;sha256&#39;<\/code>, <code>&#39;sha512&#39;<\/code>, etc.  On recent releases, <code>openssl\nlist-message-digest-algorithms<\/code> will display the available digest\nalgorithms.\n\n<\/p>\n<p>Example: this program that takes the sha1 sum of a file\n\n<\/p>\n<pre><code>var filename = process.argv[2];\nvar crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar shasum = crypto.createHash(&#39;sha1&#39;);\n\nvar s = fs.ReadStream(filename);\ns.on(&#39;data&#39;, function(d) {\n  shasum.update(d);\n});\n\ns.on(&#39;end&#39;, function() {\n  var d = shasum.digest(&#39;hex&#39;);\n  console.log(d + &#39;  &#39; + filename);\n});<\/code><\/pre>\n","p":[{"o":false,"t":"algorithm","d":"","type":""}]},"createHmac":{"y":"crypto.createHmac(algorithm, key)","s":"<p>Creates and returns a hmac object, a cryptographic hmac with the given\nalgorithm and key.\n\n<\/p>\n<p>It is a <a href=\"stream.html\">stream<\/a> that is both readable and writable.  The\nwritten data is used to compute the hmac.  Once the writable side of\nthe stream is ended, use the <code>read()<\/code> method to get the computed\ndigest.  The legacy <code>update<\/code> and <code>digest<\/code> methods are also supported.\n\n<\/p>\n<p><code>algorithm<\/code> is dependent on the available algorithms supported by\nOpenSSL - see createHash above.  <code>key<\/code> is the hmac key to be used.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""},{"o":false,"t":"key","d":"","type":""}]},"createCipher":{"y":"crypto.createCipher(algorithm, password)","s":"<p>Creates and returns a cipher object, with the given algorithm and\npassword.\n\n<\/p>\n<p><code>algorithm<\/code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;<\/code>, etc.  On\nrecent releases, <code>openssl list-cipher-algorithms<\/code> will display the\navailable cipher algorithms.  <code>password<\/code> is used to derive key and IV,\nwhich must be a <code>&#39;binary&#39;<\/code> encoded string or a <a href=\"buffer.html\">buffer<\/a>.\n\n<\/p>\n<p>It is a <a href=\"stream.html\">stream<\/a> that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the <code>read()<\/code> method to get the enciphered\ncontents.  The legacy <code>update<\/code> and <code>final<\/code> methods are also supported.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""},{"o":false,"t":"password","d":"","type":""}]},"createCipheriv":{"y":"crypto.createCipheriv(algorithm, key, iv)","s":"<p>Creates and returns a cipher object, with the given algorithm, key and\niv.\n\n<\/p>\n<p><code>algorithm<\/code> is the same as the argument to <code>createCipher()<\/code>.  <code>key<\/code> is\nthe raw key used by the algorithm.  <code>iv<\/code> is an <a href=\"http:\/\/en.wikipedia.org\/wiki\/Initialization_vector\">initialization\nvector<\/a>.\n\n<\/p>\n<p><code>key<\/code> and <code>iv<\/code> must be <code>&#39;binary&#39;<\/code> encoded strings or\n<a href=\"buffer.html\">buffers<\/a>.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""},{"o":false,"t":"key","d":"","type":""},{"o":false,"t":"iv","d":"","type":""}]},"createDecipher":{"y":"crypto.createDecipher(algorithm, password)","s":"<p>Creates and returns a decipher object, with the given algorithm and\nkey.  This is the mirror of the [createCipher()][] above.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""},{"o":false,"t":"password","d":"","type":""}]},"createDecipheriv":{"y":"crypto.createDecipheriv(algorithm, key, iv)","s":"<p>Creates and returns a decipher object, with the given algorithm, key\nand iv.  This is the mirror of the [createCipheriv()][] above.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""},{"o":false,"t":"key","d":"","type":""},{"o":false,"t":"iv","d":"","type":""}]},"createSign":{"y":"crypto.createSign(algorithm)","s":"<p>Creates and returns a signing object, with the given algorithm.  On\nrecent OpenSSL releases, <code>openssl list-public-key-algorithms<\/code> will\ndisplay the available signing algorithms. Examples are <code>&#39;RSA-SHA256&#39;<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""}]},"createVerify":{"y":"crypto.createVerify(algorithm)","s":"<p>Creates and returns a verification object, with the given algorithm.\nThis is the mirror of the signing object above.\n\n<\/p>\n","p":[{"o":false,"t":"algorithm","d":"","type":""}]},"createDiffieHellman":{"y":"crypto.createDiffieHellman(prime, [encoding])","s":"<p>Creates a Diffie-Hellman key exchange object using the supplied prime.\nThe generator used is <code>2<\/code>. Encoding can be <code>&#39;binary&#39;<\/code>, <code>&#39;hex&#39;<\/code>, or\n<code>&#39;base64&#39;<\/code>.  If no encoding is specified, then a buffer is expected.\n\n<\/p>\n","p":[{"o":false,"t":"prime","d":"","type":""},{"o":true,"t":"encoding","d":"","type":""}]},"getDiffieHellman":{"y":"crypto.getDiffieHellman(group_name)","s":"<p>Creates a predefined Diffie-Hellman key exchange object.  The\nsupported groups are: <code>&#39;modp1&#39;<\/code>, <code>&#39;modp2&#39;<\/code>, <code>&#39;modp5&#39;<\/code> (defined in [RFC\n2412][]) and <code>&#39;modp14&#39;<\/code>, <code>&#39;modp15&#39;<\/code>, <code>&#39;modp16&#39;<\/code>, <code>&#39;modp17&#39;<\/code>,\n<code>&#39;modp18&#39;<\/code> (defined in [RFC 3526][]).  The returned object mimics the\ninterface of objects created by [crypto.createDiffieHellman()][]\nabove, but will not allow to change the keys (with\n[diffieHellman.setPublicKey()][] for example).  The advantage of using\nthis routine is that the parties don&#39;t have to generate nor exchange\ngroup modulus beforehand, saving both processor and communication\ntime.\n\n<\/p>\n<p>Example (obtaining a shared secret):\n\n<\/p>\n<pre><code>var crypto = require(&#39;crypto&#39;);\nvar alice = crypto.getDiffieHellman(&#39;modp5&#39;);\nvar bob = crypto.getDiffieHellman(&#39;modp5&#39;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n\/* alice_secret and bob_secret should be the same *\/\nconsole.log(alice_secret == bob_secret);<\/code><\/pre>\n","p":[{"o":false,"t":"group_name","d":"","type":""}]},"pbkdf2":{"y":"crypto.pbkdf2(password, salt, iterations, keylen, callback)","s":"<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments <code>(err, derivedKey)<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"password","d":"","type":""},{"o":false,"t":"salt","d":"","type":""},{"o":false,"t":"iterations","d":"","type":""},{"o":false,"t":"keylen","d":"","type":""},{"o":false,"t":"callback","d":"","type":""}]},"pbkdf2Sync":{"y":"crypto.pbkdf2Sync(password, salt, iterations, keylen)","s":"<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.\n\n<\/p>\n","p":[{"o":false,"t":"password","d":"","type":""},{"o":false,"t":"salt","d":"","type":""},{"o":false,"t":"iterations","d":"","type":""},{"o":false,"t":"keylen","d":"","type":""}]},"randomBytes":{"y":"crypto.randomBytes(size, [callback])","s":"<p>Generates cryptographically strong pseudo-random data. Usage:\n\n<\/p>\n<pre><code>\/\/ async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n});\n\n\/\/ sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n} catch (ex) {\n  \/\/ handle error\n  \/\/ most likely, entropy sources are drained\n}<\/code><\/pre>\n<p>NOTE: Will throw error or invoke callback with error, if there is not enough\naccumulated entropy to generate cryptographically strong data. In other words,\n<code>crypto.randomBytes<\/code> without callback will not block even if all entropy sources\nare drained.\n\n<\/p>\n","p":[{"o":false,"t":"size","d":"","type":""},{"o":true,"t":"callback","d":"","type":""}]},"pseudoRandomBytes":{"y":"crypto.pseudoRandomBytes(size, [callback])","s":"<p>Generates <em>non<\/em>-cryptographically strong pseudo-random data. The data\nreturned will be unique if it is sufficiently long, but is not\nnecessarily unpredictable. For this reason, the output of this\nfunction should never be used where unpredictability is important,\nsuch as in the generation of encryption keys.\n\n<\/p>\n<p>Usage is otherwise identical to <code>crypto.randomBytes<\/code>.\n\n<\/p>\n","p":[{"o":false,"t":"size","d":"","type":""},{"o":true,"t":"callback","d":"","type":""}]}}
